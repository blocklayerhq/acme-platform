input name {
    type = "string"
    // FIXME: this is a placeholder until the pipeline name is provided directly by the runtime
    // (or an equivalent pipeline-unique identifier)
}
task annotation_key {
    op = "text.sh"
    src = input.name
    cmd = "sed -e 's/_/-/g' -e 's/^/bl-/'"
}

/// Acme Clothing is based on an open-source project called "crate".
/// For now we deploy directly from the upstream crate repository, 
/// to make sure we can deploy an application without controlling its
/// development environment.

task monorepo {
    op = "git.clone"
    src = "https://github.com/atulmy/crate.git"
}


//
// API deployment
//

// By default, get API source code from a subtree of the monorepo.
// Optionally, override API source code with the "api_src" input.
task api_src {
    op = "fs.subtree"
    src = monorepo.out
    path = "code/api"
}
input api_src {
    type = "fstree"
    value = api_src.out
}

task api_docker_image {
    op = "docker.build"
    src = input.api_src
    dockerfile = input.api_docker_image_dockerfile
}
input api_docker_image_dockerfile {
    type = "string"
    value = <<-EOF
	from alpine as api
	run apk update
	run apk add npm
	run npm config set unsafe-perm true
	run apk add gcc g++ make
	run apk add python
	run ["npm", "install", "-g", "nodemon"]
	run ["npm", "install", "-g", "babel-cli"]
	copy . /src/
	workdir /src
	run npm install
	run npm run build:prod
	env NODE_ENV=production
	cmd ["npm", "run", "start:server"]
EOF
}

input api_gcp_project {
    type = "string"
}
input api_gcp_service_key {
    type = "string"
}

task api_docker_repo {
    op = "gcr.push"
    image = api_docker_image.out
    name = "acme-clothing-api"
    # FIXME: Since we're building from an input, we shouldn't use the task's git
    # commit as a tag
    tag = monorepo.commit
    project = input.api_gcp_project
    service-key = input.api_gcp_service_key
}

task api_kubernetes_config {
    op = "text.template"
    syntax = "shell"
    src = input.api_kubernetes_config_src
    vars_IMG = api_docker_repo.full-name
    vars_DB_CONFIG = api_db_config.out
}
// FIXME: rename "_src" to "_template" for clarity
input api_kubernetes_config_src {
    type = "string"
    value = <<EOF
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: acme-clothing-api
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: acme-clothing-api
    spec:
      volumes:
       - name: api-db-config
         secret:
           secretName: api-db-config
           items:
           - key: json
             path: json
      containers:
        - image: $IMG
          name: api
          command: ["npm", "run", "start:server"]
          volumeMounts:
            - name: api-db-config
              subPath: json
              mountPath: /src/src/config/database.json
              readOnly: true
          ports:
            - name: api-port
              containerPort: 8000
            - name: debug-port
              containerPort: 8001
          env:
      initContainers:
        - name: db-setup
          image: $IMG
          command: ["npm", "run", "setup:db"]
          env:
          volumeMounts:
            - name: api-db-config
              subPath: json
              mountPath: /src/src/config/database.json
              readOnly: true
---
apiVersion: v1
kind: Service
metadata:
  name: acme-clothing-api
spec:
  type: NodePort
  selector:
    app: acme-clothing-api
  ports:
    - name: api-port
      port: 8000
      targetPort: 8000
    - name: debug-port
      port: 8001
      targetPort: 8001
---
apiVersion: v1
kind: Secret
metadata:
  name: api-db-config
type: Opaque
stringData:
  json: '
    $DB_CONFIG
  '

EOF
}

// FIXME: rename to api_kubernetes_namespace
task api_deployment {
    op = "gke.deploy-file"
    // tool = "kubectl"
    src = api_kubernetes_config.out
    project = input.api_gcp_project
    service-key = input.api_gcp_service_key
    kubernetes-cluster = input.api_deployment_cluster
    // FIXME: rename the bot input 'region' to the more accurate 'compute_zone'
    region = input.api_deployment_compute_zone
    namespace = input.api_deployment_namespace
}
input api_deployment_compute_zone {
    type = "string"
    value = "us-west2"
}
input api_deployment_cluster {
    type = "string"
}
input api_deployment_namespace {
    type = "string"
    value = annotation_key.out
}
task api_deployment_url {
    op = "text.printf"
    fmt = "https://api.%s.infralabs.io"
    args_0 = annotation_key.out
}

task api_db {
    op = "mysql.create-db"
    db_name = annotation_key.out
    host = input.api_db_host_public
    admin_user = input.api_db_admin_user
    admin_password = input.api_db_admin_password
}
// DB public IP is authorized from the agent IP.
// We use it to provision the DB from the bot directly
input api_db_host_public {
    type = "string"
}
// DB private IP is authorized from the GKE Kubernetes network
// We use it to migrate the DB from a kubernetes initContainer on GKE
input api_db_host_private {
    type = "string"
}
input api_db_admin_user {
    type = "string"
}
input api_db_admin_password {
    type = "string"
}

task api_db_config {
    op = "env.to_json"
    keys_user = input.api_db_admin_user
    keys_password = input.api_db_admin_password
    keys_host = input.api_db_host_private
    keys_db_name = annotation_key.out
    transform = <<-EOF
	{
		production: {
			username: .user,
			password: .password,
			database: .db_name,
			host:     .host,
                        dialect:  "mysql",
                        seederStorage: "sequelize"
		}
	}
EOF
}

///
/// Frontend deployment
///
/// Application stack: ReactJS
/// Infrastructure: Netlify
///

// By default, get frontend source code from a subtree of the monorepo.
// Optionally, override frontend source code with the "frontend_src" input.

task frontend_src {
    op = "fs.subtree"
    src = monorepo.out
    path = "code/web"
}
input frontend_src {
    type = "fstree"
    value = frontend_src.out
}

// Assemble the npm/node build environment for the frontend
task frontend_buildenv {
    op = "env.to_shell"
    // FIXME: this is a hack to workaround the lack of map type
    // Close your eyes and imagine a map[string]string :)
    keys_NODE_ENV    = "production"
    keys_APP_URL     = frontend_deployment_url.out
    keys_APP_URL_API = api_deployment_url.out
}

task frontend_src_with_buildenv {
    op = "fs.write_text"
    src = input.frontend_src
    path = ".env"
    text = frontend_buildenv.out
}

task frontend_build {
    op = "npm.build"
    src = frontend_src_with_buildenv.out
    build_script = "build:client"
    build_dir = "public"
}

task frontend_deployment {
    op = "netlify.deploy"
    src = frontend_build.out
    name = input.frontend_deployment_name
    auth-token = input.frontend_deployment_auth_token
    create-site = "true"
}
input frontend_deployment_name {
    type = "string"
    value = annotation_key.out
}
input frontend_deployment_auth_token {
    type = "string"
}
task frontend_deployment_url {
    op = "text.printf"
    fmt = "https://%s.netlify.com"
    args_0 = input.frontend_deployment_name
}
