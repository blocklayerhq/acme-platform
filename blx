#!/bin/bash

## TODO:
## - consolidate each env into a single file
## - to inspect: eval a subset of the tree
## - to edit/configure: eval a subset, write to temp file, edit, merge back in

## - condolidate .bl/compiled into a single file

set -eu

blx() {
	cmd=${1:-}; shift || true
	case $cmd in
		env|component|island|inspect|get|help)
			"blx$(cap $cmd)" "$@"
			;;
		"")
			blxHelp
			;;
		*)
			fatal "unsupported command: $cmd"
			;;
	esac
}

blxInspect() {
	cueEval .bl/compiled "$@"
}

blxGet() {
	cueEval .bl/compiled "$@" | jq -r .
}

blxEnv() {
	cmd=${1:-}; shift || true
	case $cmd in
		stage|deploy|list|configure|components|create|update|destroy)
			"blxEnv$(cap $cmd)" "$@"
			;;
		"")
			blxEnvHelp
			;;
		*)
			fatal "unsupported command: env $cmd"
			;;
	esac
}
blxComponent() {
	cmd=${1:-}; shift || true
	case $cmd in
		list|search|install|update|configure|remove)
			"blxComponent$(cap $cmd)" "$@"
			;;
		"")
			blxComponentHelp
			;;
		*)
			fatal "unsupported command: component $cmd"
			;;
	esac
}
blxIsland() {
	cmd=${1:-}; shift || true
	case $cmd in
		install|update|destroy)
			"blxIsland$(cap $cmd)" "$@"
			;;
		"")
			blxIslandHelp
			;;
		*)
			fatal "unsupported command: island $cmd"
			;;
	esac
}
blxHelp() {
	cat <<-EOF
		blx: experimental blocklayer CLI

		Usage: blx [OPTIONS] COMMAND [ARGS...]

			env			Manage staging environments
			component	Manage the individual components of an environment
			island		Manage the infrastructure running environments
		EOF
}


###
### ENV SUB-COMMANDS
###

blxEnvHelp() {
	cat <<-EOF
		Usage: blx env COMMAND
		
		Manage Blocklayer staging environments
		
			stage          Submit changes to deploy in an environment
			deploy         Deploy all staged changes for an environment
		
			list           Show a list of environments
			configure      Change the configuration of an environment
			components     Show a list of components installed on an environment
			create         Create a new environment
			update         Update an environment to the latest components and blueprint
			destroy        Destroy an environment and its components
	EOF
}

blxEnvList() {
	ls .bl/env | cat
}

blxEnvCreate() {
	env="${1:?unspecified name}"
	mkdir -p .bl/env
	if [ -e .bl/env/"$env" ]; then
		echo >&2 "Env $env already exists"
		return 1
	fi
	tmp="$(mktemp -d)"
	cat <<-EOF > "$tmp/name.cue"
		env "$env": {
			name: "$env"
		}
	EOF
	cat <<-EOF > "$tmp/config.cue"
		env "$env": {

		    // Target address goes here (eg. www.myapp.com)
		    target: "localhost"

		    keychain: {
		        // Env-specific passwords & keys go here
		    }

		    settings: {
		        // Env-specific settings go here
		    }
		}
	EOF
	"${EDITOR:-vim}" "$tmp/config.cue"
	mkdir "$(envdir $env)"
	cp -a "$tmp/" "$(envdir $env)/"
	compile
	echo >&2 "Successfully created env '$env'"
}

blxEnvDestroy() {
	env="${1:?unspecified env name}"
	rm -fr .bl/env/"$env"
	compile
}


###
### COMPONENT SUB-COMMANDS
###

blxComponentHelp() {
	cat <<-EOF
		Usage: blx component COMMAND
		
		Manage individual components of a staging environment
		
			list            Show a list of installed components
			search          Search the catalog of available components
			install         Install a new component in an environment
			update          Update an installed component
			configure       Change the configuration of an installed component
			remove          Remove a component from an environment
	EOF
}

blxComponentList() {
	echo "ENV		BLOCK"
	ls .bl/env | {
		while read env; do
			ls "$(envdir $env)/component" 2>/dev/null | {
				while read componentName; do
					echo "$env		$componentName"
				done
			}
		done
	}
}

blxComponentSearch() {
	(
		cd .bl/catalog/component 2>/dev/null || {
			echo >&2 "component catalog not available. Your blx install may be broken"
			return 1
		}
		find * -type f | { while read -r path; do dirname "$path"; done; }
	)
}

# TODO: make all changes in a complete copy of .bl,
# then validate it all, THEN copy the change back.
# Later this can be a git merge to avoid conflicts etc.

blxComponentInstall() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	tmp="$(mktemp -d)"
	cp -a .bl/ "$tmp/.bl/"
	echo >&2 "Staging change in $tmp"
	# Everything inside the subprocess happens in the temp sandbox
	(
		cd "$tmp" # later this can be HOME=$tmp

		# Env must exist
		if [ ! -e "$(envdir $env)" ]; then
			echo >&2 "No such env: $env"
			return 1
		fi

		# Component must not exist
		dir="$(componentdir $env $component)"
		if [ -e "$dir" ]; then
			echo >&2 "component '$component' already installed in env '$env'"
			return 1
		fi

		# Create component dir
		mkdir -p "$dir"

		# Create placeholder user config (to be edited further by the user)
		cat > "$dir/config.cue" <<-EOF
			env "$env" component "$component": {

				// Change this to the component blueprint to use
				// To search for available component blueprints: "$0 component search"
			    blueprint: ""

			    settings: {
			        // Env-specific component settings here
			    }
			}
		EOF

		# Copy the right blueprint from the catalog into the component config, then compile
		updateComponent() {
			env="${1:?unspecified env name}"
			component="${2:?unspecified component name}"
			dir="$(componentdir $env $component)"
			blueprint="$(cueEval $dir env[\"$env\"].component[\"$component\"].blueprint | jq -r .)"
			cp ".bl/catalog/component/$blueprint/blueprint.cue" "$dir/"
		}

		# Loop: edit config / compile, until it works or user gives up
		while true; do
			"${EDITOR:-vim}" "$dir/config.cue"
			if updateComponent "$env" "$component" && compile; then
				break
			else
				read -p "There were errors in the component configuration. Try again? [Yn] " rep
				case rep in
					Y|y|"") continue ;;
					*) return 1;;
				esac
			fi
		done

	)

	# Success! Copy the new configuration back
	# FIXME: does cp -a sync remove files too? If not, use rsync
	cp -a "$tmp/" ".bl/"

	echo >&2 Successfully installed component '$component' in env '$env'
}

blxComponentInstallOld() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	blueprint="${3:?unspecified component source}"


	# Create template component
	tmp=$(mktemp -d)
	cat >"$tmp/config.cue" <<-EOF
		env $env component "$component": {

		    blueprint: "$blueprint"

		    settings: {
		        // Env-specific component settings here
		    }
		}
	EOF

	compileComponent() {
		dir="${1:?unspecified component dir}"
		# Install component blueprint from catalog
		blueprint="$(cueEval $tmp env[\"$env\"].component[\"$component\"].blueprint | jq -r .)"
			cp ".bl/catalog/component/$blueprint/blueprint.cue" "$tmp/blueprint.cue"
#
# FIXME: switching to new implementation of blxComponentInstall
#			if cueEval "$tmp" >/dev/null
#			break
#	done

	}
	while true; do
			"${EDITOR:-vim}" "$tmp/config.cue"

			if [ compileComponent "$tmp" ]; then
				read -p "There were errors in the component configuration. Try again? [Yn] " rep
				case rep in
					Y|y|"") continue ;;
					*) break ;;
				esac
			fi
	done


	mkdir -p "$dir"
	cp -a "$tmp/" "$dir/"

	compile
	echo >&2 "Successfully installed component '$component' in env '$env'"
}



blxComponentConfigure() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	# Copy component to temporary sandbox
	dir="$(componentdir $env $component)"
	userConfig="$dir/configure.cue"
	tmp="$(mktemp)"
	if [ -e "$userConfig" ]; then
		cp "$userConfig" "$tmp"
	fi
	"${EDITOR:-vim}" "$tmp"
	mv "$tmp" "$userConfig"
	compile
}

blxComponentRemove() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	# Env must exist
	if [ ! -e "$(envdir $env)" ]; then
		echo >&2 "No such env: $env"
		return 1
	fi
	# Component must exist
	dir="$(componentdir $env $component)"
	if [ ! -e "$dir" ]; then
		echo >&2 "No such component '$component' in env '$env'"
		return 1
	fi
	rm -fr "$dir"
	compile
}


##
## ISLAND SUB-COMMANDS
##

blxIslandHelp() {
	cat <<-EOF
		blx island: manage the infrastructure running staging environments

		Usage: blx island [OPTIONS] COMMAND [ARGS...]

			install     Install an island on the local machine
			update      Update the island on the local machine
			destroy     Destroy the island on the local machine, with all its data
		EOF
}

blxIslandInstall() {
	if [ -e .bl ]; then
		echo >&2 "Island already installed on local machine"
		return 1
	fi
	mkdir .bl
	blx island update "$@"
}

blxIslandDestroy() {
	rm -fr .bl
}

blxIslandUpdate() {
	# Do our best to "migrate" an incomplete install when possible
	mkdir -p \
		.bl \
		.bl/engine \
		.bl/env
	# Install latest engine code
	cat <<-EOF > .bl/engine/api.cue
		import (
			"strings"
		)
		engine: {
			version: [0, 0, 3]
			channel: "alpha"
		}

		env <envName>: {
			name: envName
			target: string
			settings <K>: _
			keychain <K>: _

			component <componentName>: {
				// 1. To be completed by env operator
				blueprint?: string
				target: *env.target|string
				settings <K>: _
				auth?: _
				input?: {
					from: string
					fromDir: string
					toDir: string
				}
				remotes: {
					pullFrom?: _
					pushTo?: _
				}

				// 2. To be completed by component author
				actions: {
					install?: string
					remove?: string
					pull?: string
					package?: string
					push?: string
				}
				info <K>: _

				// 3. Helpers provided by the engine

				// Helpers
				name: componentName
				slug: strings.Replace(strings.Replace(target, ".", "-", -1), "_", "-", -1)
			}
		}
		EOF
		cat <<-'EOF' | updateCatalog component git/repo
			catalog component "git/repo": {
				settings: {
				url: string
					ref: *"master"|string
				}

				info: {
					commitID: string
					shortCommitID: string
				}

				pull: #"""
					if [ ! -d cache/mirror]; then
						git clone --progress --mirror '\#(settings.url)' cache/mirror
					fi
					git -C cache/mirror remote update
					git clone --reference cache/mirror '\#(settings.url)' input/
					"""#

				assemble: #"""
					cp -a input/ output/
					git -C output/ reset --hard '\#(settings.ref)'
					git -C output/ rev-parse '\#(settings.ref)' > info/commitID
					git -C outputs/out rev-parse --short $(cat inputs/ref) > info/shortCommitID
					"""#

				install: {
					engine: [0, 0, 3]
					packages: {
						git: true
						"openssh-client": true
					}
				}
			}
		EOF
	compile

}

compile() {
	echo -n >&2 "--- recompiling island config... "
	sourcedirs=(engine env)
	package=${1:-bl}
	compileDir=$(mktemp -d)
	(
		cd .bl && find "${sourcedirs[@]}" -name '*.cue'
	) | {
		while read -r cuePath; do
			mkdir -p "$compileDir/$(dirname $cuePath)"
			{
				echo package $package
				cat ".bl/$cuePath"
			} > "$compileDir/$cuePath"
		done
		echo package $package > "$compileDir/$cuePath/root.cue"
	}
	cueEval "$compileDir" >/dev/null
	cp -a "$compileDir/" .bl/compiled/
	echo >&2 "Done."
}


envdir() {
	env="${1:?unspecified env name}"
	echo ".bl/env/$env"
}

componentdir() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	echo "$(envdir $env)/component/$component"
}

updateCatalog() {
	category="${1:?unspecified catalog category}"
	reference="${2:?unspecified catalog reference}"

	if [ "$category" != "component" ]; then
		echo >&2 "invalid catalog category: '$category'. Supported category: 'component'."
		return 1
	fi
	dir=".bl/catalog/$category/$reference"
	mkdir -p "$dir"
	cat > "$dir/blueprint.cue"
}

cueEval() {
	(
		cd "${1:?unspecified cue directory}"; shift || true
		shopt -s nullglob
		args=(*.cue */*.cue */*/*.cue */*/*/*.cue */*/*/*/*.cue)
		for expr in "$@"; do
			args+=(-e "$expr")
		done
		cue eval -c "${args[@]}"
	)
}
	
cuecmd() {
	cmd="${1:-main}"
	tmp="$(mktemp -d)"
	echo --- cuecmd --- $tmp
	cat > "$tmp/main_tool.cue"
	ln -s "$tmp/main_tool.cue" "$tmp/main_tool_.cue"
	cue vet "$tmp/*.cue"
	cue cmd "$cmd" "$tmp/*.cue"
}
	
cap() {
	echo "$(tr '[:lower:]' '[:upper:]' <<< ${1:0:1})${1:1}"
}

fatal() {
	echo >&2 "$@"
	exit 1
}

blx "$@"
