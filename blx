#!/bin/bash

## TODO:
## - consolidate each env into a single file
## - to inspect: eval a subset of the tree
## - to edit/configure: eval a subset, write to temp file, edit, merge back in
## - move each command/subcommand into a function, for easier editing

set -eu

blx() {
	cmd=${1:-}; shift || true
	case $cmd in
		env|component|island|help)
			"blx$(cap $cmd)" "$@"
			;;
		"")
			blxHelp
			;;
		*)
			fatal "unsupported command: $cmd"
			;;
	esac
}
blxEnv() {
	cmd=${1:-}; shift || true
	case $cmd in
		stage|deploy|list|configure|components|create|inspect|update|destroy)
			"blxEnv$(cap $cmd)" "$@"
			;;
		"")
			blxEnvHelp
			;;
		*)
			fatal "unsupported command: env $cmd"
			;;
	esac
}
blxComponent() {
	cmd=${1:-}; shift || true
	case $cmd in
		list|inspect|search|install|update|configure|remove)
			"blxComponent$(cap $cmd)" "$@"
			;;
		"")
			blxComponentHelp
			;;
		*)
			fatal "unsupported command: component $cmd"
			;;
	esac
}
blxIsland() {
	cmd=${1:-}; shift || true
	case $cmd in
		list|inspect|search|install|update|configure|remove)
			"blxIsland$(cap $cmd)" "$@"
			;;
		"")
			blxIslandHelp
			;;
		*)
			fatal "unsupported command: island $cmd"
			;;
	esac
}
blxHelp() {
	cat <<-EOF
		blx: experimental blocklayer CLI

		Usage: blx [OPTIONS] COMMAND [ARGS...]

			env			Manage staging environments
			component	Manage the individual components of an environment
			island		Manage the infrastructure running environments
		EOF
}


###
### ENV SUB-COMMANDS
###

blxEnvHelp() {
	cat <<-EOF
		Usage: blx env COMMAND
		
		Manage Blocklayer staging environments
		
			stage          Submit changes to deploy in an environment
			deploy         Deploy all staged changes for an environment
		
			list           Show a list of environments
			configure      Change the configuration of an environment
			components     Show a list of components installed on an environment
			create         Create a new environment
			inspect        Show information on an environment
			update         Update an environment to the latest components and blueprint
			destroy        Destroy an environment and its components
	EOF
}

blxEnvList() {
	ls .bl/env | cat
}

blxEnvInspect() {
	if [ $# -eq 0 ]; then
		echo >&2 "unspecified env name"
		return 1
	fi
	for env in "$@"; do
			expr+=("env[\"$env\"]")
	done
	cueEval "${expr[@]}"
}

blxEnvCreate() {
					name="${1:?unspecified name}"
					mkdir -p .bl/env
					if [ -e .bl/env/"$name" ]; then
						echo >&2 "Env $name already exists"
						return 1
					fi
					mkdir .bl/env/"$name"
					cat <<-EOF > .bl/env/"$name"/name.cue
					    env "$name": {
						    name: "$name"
					    }
					EOF
				compile
}

blxEnvDestroy() {
	env="${1:?unspecified env name}"
	rm -fr .bl/env/"$env"
	compile
}


###
### COMPONENT SUB-COMMANDS
###

blxComponentHelp() {
	cat <<-EOF
		Usage: blx component COMMAND
		
		Manage individual components of a staging environment
		
			list            Show a list of installed components
			inspect         Show information on an installed component
			search          Search the catalog of available components
			install         Install a new component in an environment
			update          Update an installed component
			configure       Change the configuration of an installed component
			remove          Remove a component from an environment
	EOF
}

blxComponentList() {
	echo "ENV		BLOCK"
	ls .bl/env | {
		while read env; do
			ls "$(envdir $env)/component" 2>/dev/null | {
				while read componentName; do
					echo "$env		$componentName"
				done
			}
		done
	}
}

blxComponentInspect() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	dir="$(componentdir $env $component)"
}

blxComponentSearch() {
	(
		cd .bl/catalog/component 2>/dev/null || {
			echo >&2 "component catalog not available. Your blx install may be broken"
			return 1
		}
		find * -type f | { while read -r path; do dirname "$path"; done; }
	)
}

blxComponentUpdate() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	blueprint="${3:?unspecified component source}"

	# Env must exist
	if [ ! -e "$(envdir $env)" ]; then
		echo >&2 "No such env: $env"
		return 1
	fi
	
	# Component must not exist
	dir="$(componentdir $env $component)"
	if [ -e "$dir" ]; then
		echo >&2 "Block '$component' already installed in env '$env'"
		return 1
	fi

	# Create template component
	tmp=$(mktemp)
	cat >"$tmp" <<-EOF
		env $env component "$component": {
			blueprint: "$blueprint"

			settings: {
				// Env-specific component settings here
			}
		}
	EOF
	"${EDITOR:-vim}" "$tmp"
	mkdir -p "$dir"
	mv "$tmp" "$dir/config.cue"

	# Install component blueprint from catalog
	cueEval "env[\"$env\"].component[\"$component\"].blueprint"
	compile
}


blxComponentConfigure() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	# Copy component to temporary sandbox
	dir="$(componentdir $env $component)"
	userConfig="$dir/configure.cue"
	tmp="$(mktemp)"
	if [ -e "$userConfig" ]; then
		cp "$userConfig" "$tmp"
	fi
	"${EDITOR:-vim}" "$tmp"
	mv "$tmp" "$userConfig"
	compile
}

blxComponentRemove() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	# Env must exist
	if [ ! -e "$(envdir $env)" ]; then
		echo >&2 "No such env: $env"
		return 1
	fi
	# Component must exist
	dir="$(componentdir $env $component)"
	if [ ! -e "$dir" ]; then
		echo >&2 "No such component '$component' in env '$env'"
		return 1
	fi
	rm -fr "$dir"
	compile
}


##
## ISLAND SUB-COMMANDS
##

blxIslandHelp() {
					cat <<-EOF
						blx island: manage the infrastructure running staging environments

						Usage: blx island [OPTIONS] COMMAND [ARGS...]

						    install     Install an island on the local machine
						    update      Update the island on the local machine
						    destroy     Destroy the island on the local machine, with all its data
						EOF

}

blxIslandInstall() {
					if [ -e .bl ]; then
						echo >&2 "Island already installed on local machine"
						return 1
					fi
					mkdir .bl
					blx island update "$@"

}

blxIslandInspect() {
	cueEval
}

blxIslandDestroy() {
	rm -fr .bl
}

blxIslandUpdate() {
					# Do our best to "migrate" an incomplete install when possible
					mkdir -p \
						.bl \
						.bl/engine \
						.bl/env
					# Install latest engine code
					cat <<-EOF > .bl/engine/api.cue
						import (
						    "strings"
						)
						engine: {
							version: [0, 0, 3]
							channel: "alpha"
						}

						env <envName>: {
							name: envName
							target: string
							settings <K>: _
							keychain <K>: _

							component <componentName>: {
								// 1. To be completed by env operator
								blueprint?: string
								target: *env.target|string
								settings <K>: _
								auth?: _
								input?: {
									from: string
									fromDir: string
									toDir: string
								}
								remotes: {
									pullFrom?: _
									pushTo?: _
								}

								// 2. To be completed by component author
								actions: {
									install?: string
									remove?: string
									pull?: string
									package?: string
									push?: string
								}
								info <K>: _

								// 3. Helpers provided by the engine

								// Helpers
								name: componentName
								slug: strings.Replace(strings.Replace(target, ".", "-", -1), "_", "-", -1)
							}
						}
						EOF
						cat <<-'EOF' | updateCatalog component git/repo
							catalog component "git/repo": {
							    settings: {
							    url: string
							        ref: *"master"|string
							    }
	
							    info: {
							        commitID: string
							        shortCommitID: string
							    }
	
							    pull: #"""
							        if [ ! -d cache/mirror]; then
							            git clone --progress --mirror '\#(settings.url)' cache/mirror
							        fi
							        git -C cache/mirror remote update
							        git clone --reference cache/mirror '\#(settings.url)' input/
							        """#
	
							    assemble: #"""
							        cp -a input/ output/
							        git -C output/ reset --hard '\#(settings.ref)'
							        git -C output/ rev-parse '\#(settings.ref)' > info/commitID
							        git -C outputs/out rev-parse --short $(cat inputs/ref) > info/shortCommitID
							        """#
	
							    install: {
							        engine: [0, 0, 3]
							        packages: {
							            git: true
							            "openssh-client": true
							        }
							    }
							}
						EOF
					compile

}

compile() {
	sourcedirs=(engine env)
	package=${1:-bl}
	compileDir=$(mktemp -d)
	(
		cd .bl && find "${sourcedirs[@]}" -name '*.cue'
	) | {
		while read -r cuePath; do
			mkdir -p "$compileDir/$(dirname $cuePath)"
			{
				echo package $package
				cat ".bl/$cuePath"
			} > "$compileDir/$cuePath"
		done
		echo package $package > "$compileDir/$cuePath/root.cue"
	}
	(cd "$compileDir" && cue vet ./...)
	cp -a "$compileDir/" .bl/compiled/
	echo "Successfully recompiled island config"
}


envdir() {
	env="${1:?unspecified env name}"
	echo ".bl/env/$env"
}

componentdir() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	echo "$(envdir $env)/component/$component"
}

updateCatalog() {
	category="${1:?unspecified catalog category}"
	reference="${2:?unspecified catalog reference}"

	if [ "$category" != "component" ]; then
		echo >&2 "invalid catalog category: '$category'. Supported category: 'component'."
		return 1
	fi
	dir=".bl/catalog/$category/$reference"
	mkdir -p "$dir"
	cat > "$dir/blueprint.cue"
}

cueEval() {
	(
		cd .bl/compiled
		shopt -s nullglob
		args=(*.cue */*.cue */*/*.cue */*/*/*.cue */*/*/*/*.cue)
		for expr in "$@"; do
			args+=(-e "$expr")
		done
		cue eval -c "${args[@]}"
	)
}
	
cuecmd() {
	cmd="${1:-main}"
	tmp="$(mktemp -d)"
	echo --- cuecmd --- $tmp
	cat > "$tmp/main_tool.cue"
	ln -s "$tmp/main_tool.cue" "$tmp/main_tool_.cue"
	cue vet "$tmp/*.cue"
	cue cmd "$cmd" "$tmp/*.cue"
}
	
cap() {
	echo "$(tr '[:lower:]' '[:upper:]' <<< ${1:0:1})${1:1}"
}

fatal() {
	echo >&2 "$@"
	exit 1
}

blx "$@"
