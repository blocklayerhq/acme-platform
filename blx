#!/bin/bash

## TODO:
## - consolidate each env into a single file
## - to inspect: eval a subset of the tree
## - to edit/configure: eval a subset, write to temp file, edit, merge back in

## - condolidate .bl/compiled into a single file

set -eu

blx() {
	debug "blx $@"
	cmd=${1:-}; shift || true
	case $cmd in
		env|component|island|inspect|get|help|debug)
			"blx$(cap $cmd)" "$@"
			;;
		"")
			blxHelp
			;;
		*)
			fatal "unsupported command: $cmd"
			;;
	esac
}

blxDebug() {
	cueCompile
}

blxGet() {
	expr="${1:-env}"
	cuecmd .bl/compiled <<-EOF
		import (
		    "tool/cli"
		)

		command main: {
		    task main: cli.Print & {
		        text: $expr
		    }
		}
	EOF
}

blxInspect() {
	cueEval .bl/compiled "$@"
}

blxEnv() {
	cmd=${1:-}; shift || true
	case $cmd in
		stage|deploy|list|configure|components|create|update|destroy)
			"blxEnv$(cap $cmd)" "$@"
			;;
		"")
			blxEnvHelp
			;;
		*)
			fatal "unsupported command: env $cmd"
			;;
	esac
}
blxComponent() {
	cmd=${1:-}; shift || true
	case $cmd in
		list|search|install|update|configure|remove)
			"blxComponent$(cap $cmd)" "$@"
			;;
		"")
			blxComponentHelp
			;;
		*)
			fatal "unsupported command: component $cmd"
			;;
	esac
}
blxIsland() {
	cmd=${1:-}; shift || true
	case $cmd in
		install|update|destroy)
			"blxIsland$(cap $cmd)" "$@"
			;;
		"")
			blxIslandHelp
			;;
		*)
			fatal "unsupported command: island $cmd"
			;;
	esac
}
blxHelp() {
	cat <<-EOF
		blx: experimental blocklayer CLI

		Usage: blx [OPTIONS] COMMAND [ARGS...]

			env			Manage staging environments
			component	Manage the individual components of an environment
			island		Manage the infrastructure running environments
		EOF
}


###
### ENV SUB-COMMANDS
###

blxEnvHelp() {
	cat <<-EOF
		Usage: blx env COMMAND
		
		Manage Blocklayer staging environments
		
			stage          Submit changes to deploy in an environment
			deploy         Deploy all staged changes for an environment
		
			list           Show a list of environments
			configure      Change the configuration of an environment
			components     Show a list of components installed on an environment
			create         Create a new environment
			update         Update an environment to the latest components and blueprint
			destroy        Destroy an environment and its components
	EOF
}

blxEnvList() {
	ls .bl/env | cat
}

blxEnvCreate() {
	env="${1:?unspecified name}"
	mkdir -p .bl/env
	if [ -e .bl/env/"$env" ]; then
		echo >&2 "Env $env already exists"
		return 1
	fi
	tmp="$(mktemp -d)"
	cat <<-EOF > "$tmp/name.cue"
		env "$env": {
			name: "$env"
		}
	EOF
	cat <<-EOF > "$tmp/config.cue"
		env "$env": {

		    // Target address goes here (eg. www.myapp.com)
		    target: "localhost"

		    keychain: {
		        // Env-specific passwords & keys go here
		    }

		    settings: {
		        // Env-specific settings go here
		    }
		}
	EOF
	"${EDITOR:-vim}" "$tmp/config.cue"
	mkdir "$(envdir $env)"
	cp -a "$tmp/" "$(envdir $env)/"
	cueCompile
	echo >&2 "Successfully created env '$env'"
}

blxEnvDestroy() {
	env="${1:?unspecified env name}"
	rm -fr .bl/env/"$env"
	cueCompile
}


###
### COMPONENT SUB-COMMANDS
###

blxComponentHelp() {
	cat <<-EOF
		Usage: blx component COMMAND
		
		Manage individual components of a staging environment
		
			list            Show a list of installed components
			search          Search the catalog of available components
			install         Install a new component in an environment
			update          Update an installed component
			configure       Change the configuration of an installed component
			remove          Remove a component from an environment
	EOF
}

blxComponentList() {
	echo "ENV		BLOCK"
	ls .bl/env | {
		while read env; do
			ls "$(envdir $env)/component" 2>/dev/null | {
				while read componentName; do
					echo "$env		$componentName"
				done
			}
		done
	}
}

blxComponentSearch() {
	(
		cd .bl/catalog/component 2>/dev/null || {
			echo >&2 "component catalog not available. Your blx install may be broken"
			return 1
		}
		find * -type f | { while read -r path; do dirname "$path"; done; }
	)
}

# TODO: make all changes in a complete copy of .bl,
# then validate it all, THEN copy the change back.
# Later this can be a git merge to avoid conflicts etc.

blxComponentInstall() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	# Env must exist
	if [ ! -e "$(envdir $env)" ]; then
		echo >&2 "No such env: $env"
		return 1
	fi

	# Component must not exist
	dir="$(componentdir $env $component)"
	if [ -e "$dir" ]; then
		echo >&2 "component '$component' already installed in env '$env'"
		return 1
	fi

	# Create component dir
	debug "mkdir -p $dir"
	mkdir -p "$dir"

	# Create placeholder user config (to be edited further by the user)
	cat > "$dir/config.cue" <<-EOF
		env "$env" component "$component": {

			// Change this to the component blueprint to use
			// To search for available component blueprints: "$0 component search"
		    blueprint: ""

		    settings: {
		        // Env-specific component settings here
		    }
		}
	EOF

	blx component configure "$env" "$component"

	echo >&2 Successfully installed component '$component' in env '$env'
}

blxComponentConfigure() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	dir="$(componentdir $env $component)"

	# Loop: edit config / compile, until it works or user gives up
	while true; do
		"${EDITOR:-vim}" "$dir/config.cue"
		if cueCompile; then
			break
		else
			read -p "> Component configuration has errors. Press enter to fix, or Ctrl-C to abort: "
		fi
	done
	echo "Successfully configured component '$component' of env '$env'"
}

blxComponentRemove() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"

	# Env must exist
	if [ ! -e "$(envdir $env)" ]; then
		echo >&2 "No such env: $env"
		return 1
	fi
	# Component must exist
	dir="$(componentdir $env $component)"
	if [ ! -e "$dir" ]; then
		echo >&2 "No such component '$component' in env '$env'"
		return 1
	fi
	rm -fr "$dir"
	cueCompile
}


##
## ISLAND SUB-COMMANDS
##

blxIslandHelp() {
	cat <<-EOF
		blx island: manage the infrastructure running staging environments

		Usage: blx island [OPTIONS] COMMAND [ARGS...]

			install     Install an island on the local machine
			update      Update the island on the local machine
			destroy     Destroy the island on the local machine, with all its data
		EOF
}

blxIslandInstall() {
	if [ -e .bl ]; then
		echo >&2 "Island already installed on local machine"
		return 1
	fi
	mkdir .bl
	blx island update "$@"
}

blxIslandDestroy() {
	rm -fr .bl
}

blxIslandUpdate() {
	# Do our best to "migrate" an incomplete install when possible
	mkdir -p \
		.bl \
		.bl/engine \
		.bl/env
	# Install latest engine code
	cat <<-'EOF' > .bl/engine/api.cue
		import (
		    "strings"
			"encoding/json"
			"strconv"
		)
		engine: {
		    version: [0, 0, 3]
		    channel: "alpha"
		}

		env <envName>: {
		    name: envName
		    target: string
		    TARGET=target, component <componentName> target: *TARGET|string
		    settings <K>: _
		    keychain <K>: _

		    component <componentName>: Component & {
		        // Helpers
		        name: componentName
			}

		    containers <Name>: LinuxAlpineContainer & {
			     settings systemPackages bash: true
			}
		    containers: {
		        for name, c in component {
		        	"\(name)": {
						settings: {
							alpineVersion: [3, 9, 4]
							alpineDigest: "sha256:769fddc7cc2f0a1c35abb2f91432e8beecf83916c421420e6a6da9f8975464b6"
							appDir: "/workspace"
							appRun: ["/entrypoint.sh"]
							appInstall: [
								["mkdir", "/input", "/output", "/info", "/cache"]
								// FIXME: inject entrypoint script
							]
		    	    	    systemPackages: {
				                 "openssh-client": true
				                 "git": true
				            }
						}
		        	}
		        }
		    }
		}

		LinuxAlpineContainer :: {
		    settings: {
		        env? <Key>: string
		        appDir : *"/app"|string
		        appInstall: *[[]]|[...[...string]]
		        appRun: [...string]
		        alpineVersion: *[3]|[...int]
		        alpineDigest?: string
		        systemPackages <spkg>: true
		        adhocPackages <ahpkg>: [...[...string]]
		    }

			dockerfile: {
		        out: """
		            from alpine:\(alpineVersionWithDigest)
		            # Install system packages
		            \(systemPackages)
		            # Install adhoc packages
		            \(adhocPackages)
		            # Copy app source into container
		            COPY . \(settings.appDir)
		            # Set environment for app install and run
		            \(env)
		            # Set workdir for app install and run
		            WORKDIR \(settings.appDir)
		            # Install app
		            \(appInstall)
		            # Configure run command
		            \(appRunCmd)
		            """
		        alpineVersion: strings.Join([strconv.FormatInt(n, 10) for n in settings.alpineVersion], ".")
		        alpineDigest: ({dig:settings.alpineDigest, out:string} & ({dig:"", out:""}|{dig:_, out:"@\(dig)"})).out
		        alpineVersionWithDigest: "\(alpineVersion)\(alpineDigest)"
		        systemPackages: strings.Join(["RUN apk add -U --no-cache \(pkg)" for pkg, _ in settings.systemPackages], "\n")
		        adhocPackages: strings.Join(["RUN \(json.Marshal(cmd))" for cmd in settings.adhocPackages], "\n")
		        env: strings.Join(["ENV \(k)=\(v)" for k, v in settings.env|{}], "\n")
		        appInstall: strings.Join(["RUN \(strings.Join(cmd, " "))" for cmd in settings.appInstall], "\n")
		        appRunCmd: "CMD \(strings.Join(settings.appRun, " "))"
		    }
		}
		
			Component :: {
		        name: _
		        target: _
		        slug: strings.Replace(strings.Replace(target, ".", "-", -1), "_", "-", -1)

		        // 1. To be completed by env operator
		        blueprint?: string
				settings: {...}
		        auth?: _
		        input?: {
		            from: string
			        fromDir: string
			        toDir: string
		        }
		        remotes: {
		            pullFrom?: _
		            pushTo?: _
		        }

		        // 2. To be completed by component author
		        actions: {
		            install?: string
		            remove?: string
		            pull?: string
		            package?: string
		            push?: string
		        }
		        info <K>: _
		    }
		EOF


		# CATALOG COMPONENT: git/repo
		cat <<-'EOF' | updateCatalog component git/repo
			package repo

			settings: {
			    url: string
			    ref: *"master"|string
			}

			/* FIXME
			info: {
			    commitID: string
			    shortCommitID: string
			}
			*/

			actions: {
			    pull: #"""
			        if [ ! -d cache/mirror]; then
			            git clone --progress --mirror '\#(settings.url)' cache/mirror
			        fi
			        git -C cache/mirror remote update
			        git clone --reference cache/mirror '\#(settings.url)' input/
			        """#

			    assemble: #"""
			        cp -a input/ output/
			        git -C output/ reset --hard '\#(settings.ref)'
			        git -C output/ rev-parse '\#(settings.ref)' > info/commitID
			        git -C outputs/out rev-parse --short $(cat inputs/ref) > info/shortCommitID
			        """#

			    install: {
			        engine: [0, 0, 3]
			        packages: {
			            git: true
			            "openssh-client": true
			        }
			    }
			}
		EOF
	cueCompile

}


cueCompile() {
	tmp="$(mktemp -d)"
	touch "$tmp/cue.mod"
	debug cueCompile tmp=$tmp

	# 1. Flatten the CUE config hierarchy into a single directory `$tmp/parts/*.cue`
	mkdir "$tmp/parts"
	find .bl/env .bl/engine -name '*.cue' | {
		while read f; do
			# Flatten path into a single file ( eg. '.bl/foo/bar.cue' becomes 'foo_bar.cue')
			flatf="$(sed -E -e 's/^\.bl\///' -e 's/\//_/g' <<<$f)"
			debug "cueCompile() { cp $f $tmp/parts/$flatf }"
			cp "$f" "$tmp/parts/$flatf"
		done
	}

	codegen() {
	ln -s "$(pwd)/.bl/catalog" "$tmp/catalog"
	(
		touch "$tmp/main.cue" # Command should work even if there are no cue files
		cd "$tmp" && cuecmd . <<-'EOF'
			import (
			    "strings"
			    "tool/exec"
			    "tool/file"
			)
	
			command main: {
			    task codegenWrite: file.Create & {
			        filename: "codegen.cue"
			        contents: codegen.code
			    }
	
			    task codegenSetup: exec.Run & {
			        cmd: ["bash", "-c", codegen.setup]
			    }
			}
	
			// Generate import/apply CUE code from env config
			codegen : {
			    code: """
			        import (
			            \(strings.Join([import.code for _, import in codegen.imports if !import.setupOnly], "\n"))
			        )
	
			        \(strings.Join([apply.code for _, apply in codegen.apply if !apply.import.setupOnly], "\n"))
			        """
	
				setup: """
			        \(strings.Join([import.setup for _, import in codegen.imports], "\n"))
					"""
	
				imports: {...}
				apply: {...}
				
			    // Always import linux/container for internal use (build component containers)
				// FIXME
			    // imports "linux/container" setupOnly: true
				// imports "linux/alpine/container" setupOnly: true
	
			    for _, e in env|{} {
			        for _, c in e.component {
						if c.blueprint != "" {
			                imports "\(c.blueprint)": {}
				            apply "\(c.name)": {
								import: imports[c.blueprint]
			                    code: """
			                        // Apply blueprint '\(c.blueprint)' to component '\(c.name)'
			                        env "\(e.name)" component "\(c.name)": /* Component & */ \(import.symbol)
			                        """
			                }
			            }
			        }
	            }
	
			    imports <importSource>: {
			        source: importSource
					symbol: *strings.Replace(source, "/", "_", -1)|string
			        cueSource: "infralabs.io/stdlib/\(source)"
			        code: """
			            // Import CUE package for blueprint '\(source)'
			            \(symbol) "\(cueSource)"
			            """
			        pkgCopyFrom: "catalog/component/\(source)"
			        pkgCopyTo: "pkg/\(cueSource)"
					setupOnly: *false|bool
			        setup: "mkdir -p '\(pkgCopyTo)' && rsync -aH --delete '\(pkgCopyFrom)/' '\(pkgCopyTo)/'"
			    }
			}
		EOF
	)
	rm "$tmp/catalog"
	}

	# 2. Setup packages in the empty workspace (for bootstrap imports)
	# This must be done before evaluating the main config, or imports will fail
	codegen
	
	# 3. Eval all parts into a single file `$tmp/main.cue`
	( cd $tmp/parts && cue eval *.cue > ../main.cue || { rm ../main.cue; return 1; } )

	# 3. Extract blueprint references from all components, and generate CUE imports
	codegen

	cueEval "$tmp" >/dev/null || return 1
	rsync -aH --delete "$tmp/" ".bl/compiled/"
}


envdir() {
	env="${1:?unspecified env name}"
	echo ".bl/env/$env"
}

componentdir() {
	env="${1:?unspecified env name}"
	component="${2:?unspecified component name}"
	echo "$(envdir $env)/component/$component"
}

updateCatalog() {
	category="${1:?unspecified catalog category}"
	reference="${2:?unspecified catalog reference}"

	if [ "$category" != "component" ]; then
		echo >&2 "invalid catalog category: '$category'. Supported category: 'component'."
		return 1
	fi
	dir=".bl/catalog/$category/$reference"
	mkdir -p "$dir"
	cat > "$dir/blueprint.cue"
}

cueEval() {
	(
		cd "${1:?unspecified cue directory}"; shift || true
		shopt -s nullglob
		files=(*.cue)
		args="${files[@]}"
		for expr in "$@"; do
			args+=(-e "$expr")
		done
		cue eval -c ${args[@]} || {
			if [ "${DEBUG:-}" ]; then
				for f in ${files[@]}; do
					echo ${f}:;
					cat -en $f | sed 's/	/<TAB>/g'
					echo ---
				done
			fi
			return 1
		} >&2
	)
}
	
cuecmd() {
	dir="${1:?unspecified target dir}"
	cmd="${2:-main}"
	id="$RANDOM"
	file="cmd_${id}_tool.cue"
	cat > "$dir/$file"
	(
		cd $dir
		debug "cuecmd() { cue eval -c }"
		# Hack to get more readable errors on the tool file
		file_="cmd_${id}_tool_.cue"
		ln -s "$file" "$file_"
		cue eval *.cue >/dev/null || {
			for f in *.cue; do
				if [ "$f" = "$file_" ]; then continue; fi
				echo ${f}:;
				cat -en $f | sed 's/	/<TAB>/g'
				echo ---
			done
			return 1
		} >&2
		rm "$file_"
		debug "cuecmd() { cue cmd }"
		cue cmd "$cmd" *.cue
		rm *_tool.cue
	) || return 1
	debug "cuecmd() success"
}
	
cap() {
	echo "$(tr '[:lower:]' '[:upper:]' <<< ${1:0:1})${1:1}"
}

fatal() {
	echo >&2 "$@"
	exit 1
}

debug() {
	if [ "${DEBUG:-}" ]; then
		echo >&2 --- "$@"
	fi
}

blx "$@"
